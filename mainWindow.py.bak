"""Subclass of wxApplicationFrame, which is generated by wxFormBuilder."""

import matplotlib
matplotlib.interactive(True)
matplotlib.use('WXAgg')

import wx
import wxApplicationProject
import cv2
import itertools
import xarray as xr


from matplotlib.backends.backend_wxagg import FigureCanvasWxAgg
from matplotlib.backends.backend_wx import NavigationToolbar2Wx, wxc
from matplotlib.figure import Figure
from matplotlib import patches as mpatches
import matplotlib.pyplot as plt

import numpy as np
from multiprocessing import Pool, cpu_count

from my_utils.displacement.displacement import Displacement, Bayesian
from my_utils.displacement.statistics import robust_statistics_with_mad
from my_utils.displacement.load_results import load
from method4pxpys import Method

import displacementWindow
import pcaWindow
import spatialDifferenceWindow
import dampedAnalysisWindow
import SettingDialog
import DisplacementDeflectionWindow
import DisplacementVectorWindow
import RelativeDisplacementWindow
import RunDialog


import setObsPoint_Dialog
import OP_Dialog

from my_modules import search_ext
from my_modules.dialog.save import save_pickle
import os
import pickle

iconW = 24
iconH = 24
iconW2 = 36
iconH2 = 36
iconSize = wx.Size(iconW,iconH)
BaseSetting = False
PickleRead = False
colorlist = ["r", "g", "b", "c", "m", "y", "k"]

def cv2_image_to_wx_image(cv2_image): # OpenCV画像を、wx画像へ変換
    # type: (np.ndarray) -> wx.Image
    height, width = cv2_image.shape[:2]
    wx_image = wx.EmptyImage(width, height)  # type: wx.Image
    wx_image.SetData(cv2.cvtColor(cv2_image, cv2.COLOR_BGR2RGB))
    return wx_image


def createBitmapIconFromPng(file,w,h):
    image = wx.Image(file)
    image.Rescale(w,h, wx.IMAGE_QUALITY_BILINEAR )
    return image.ConvertToBitmap()

def createMainevt(self):
    #メニューバー名前をつけて保存
    self.Bind( wx.EVT_TOOL, self.m_fileMenuItem5Click, id =  self.m_fileMenuItem5.GetId())
    #メニューバー終了
    self.Bind( wx.EVT_TOOL, self.m_fileMenuItem8Click, id =  self.m_fileMenuItem8.GetId())
    self.Bind( wx.EVT_MENU, self.m_displayMenuItem9MenuSelection,id = self.m_displayMenuItem9.GetId())
    self.Bind( wx.EVT_MENU, self.m_analyzeMenuItem1MenuSelection,id = self.m_analyzeMenuItem1.GetId())
    #メニューバー分析開始
    self.Bind( wx.EVT_MENU, self.m_analyzeMenuItem4MenuSelection, id = self.m_analyzeMenuItem4.GetId())
    #メニューバー変位分析のみ開始
    self.Bind( wx.EVT_MENU, self.m_analyzeMenuItem5MenuSelection, id = self.m_analyzeMenuItem5.GetId())
    #メニューバー振動モード分析のみ開始
    self.Bind( wx.EVT_MENU, self.m_analyzeMenuItem6MenuSelection, id = self.m_analyzeMenuItem6.GetId())
    #メニューバー空間差分分析のみ開始
    self.Bind( wx.EVT_MENU, self.m_analyzeMenuItem7MenuSelection, id = self.m_analyzeMenuItem7.GetId())
    #メニューバー減衰分析のみ実施
    self.Bind( wx.EVT_MENU, self.m_analyzeMenuItem8MenuSelection, id = self.m_analyzeMenuItem8.GetId())
    self.Bind( wx.EVT_TOOL, self.m_openToolClick, id=self.m_fileMenuItem1.GetId())
    self.Bind( wx.EVT_TOOL, self.m_plotDispVector, id=self.m_displayMenuItem1.GetId())
    self.Bind( wx.EVT_TOOL, self.m_plotDispDef, id=self.m_displayMenuItem4.GetId())
    self.Bind( wx.EVT_TOOL, self.m_Relativedisplacement, id=self.m_displayMenuItem51.GetId())
    self.m_analyzeMenuItem4.Enable(False)
    self.m_analyzeMenuItem5.Enable(False)
    self.m_analyzeMenuItem6.Enable(False)
    self.m_analyzeMenuItem7.Enable(False)
    self.m_analyzeMenuItem8.Enable(False)


def createDialog(self):
    OP_Dialog = m_OP_Dialog()

def createMainInit(self):
    print('createMainInit')
    # ドラッグしているのかのフラグ
    self.DragFlag = False

    # グラフの設定
    self.axes = None
    self.artist = None
    self.backend = None
    self.cursor = None
    #分析開始フラグ
    self.Item6 = False
    self.Item7 = False
    self.Item8 = False
    # 観測点設定ダイアログ
    self.opDialog = setOP_Dialog(self)
    self.params = self.opDialog.getParam(self)
    self.results = []
    self.colordl = []  # 分析点color空き
    self.BlockNo = 0   # 観測点グルーピングNO
    self.pxpys_run = None
    self.bss_run = None
    self.pxpys = [[]]
    self.bss = [[]]
    self.bs = np.array([self.params["block_w"], self.params["block_h"]])
    self.is_background = False  # background選択フラグ
    self.is_pyramid = False  # pyramid検出フラグ
    self.layers_bs = []
    self.layers_stride = []
    self.pyramid_pxpys = None
    self.pyramid_bss = None
    self.pyramid_pxpys_bg = None
    self.pyramid_bss_bg = None
    self.expand_pxpys = None
    self.expand_bss = None
    self.expand_pxpys_bg = None
    self.expand_bss_bg = None
    self.len_pyramid = 0
    self.is_sampling = False

    self.press_count = False
    self.first_pos = []

    self.file_list = []
    self.folder_path = None
    self.image = None
    self.base_image = None
    self.frame_number = None

    self.cvimg_rgb = None




def createToolbar(self):
    # ツールバーの設定
    self.m_wxApplicationToolbar.SetToolSeparation( 5 )
    self.m_wxApplicationToolbar.SetMargins( wx.Size( 3,3 ) )
    self.m_wxApplicationToolbar.SetToolBitmapSize( iconSize )
    # 開くボタン
    self.m_openTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"開く", createBitmapIconFromPng(u"icons/open.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    # 保存ボタン    
    self.m_saveTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"保存", createBitmapIconFromPng(u"icons/save.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    # ホームボタン
    self.m_homeTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"ホーム", createBitmapIconFromPng(u"icons/home.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
    # キャプチャーボタン
    self.m_captureTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"キャプチャー", createBitmapIconFromPng(u"icons/capture.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    #    
    self.m_wxApplicationToolbar.AddSeparator()
    # 画像の情報ボタン
    self.m_imageInfoTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"画像の情報", createBitmapIconFromPng(u"icons/info.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    # ズームインボタン
    #self.m_zoomInTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"ズームイン", createBitmapIconFromPng(u"icons/zoomin.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
    # ズームインボタン    
    #self.m_zoomOutTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"ズームアウト", createBitmapIconFromPng(u"icons/zoomout.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
    # ズームボタン
    self.m_zoomTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"ズーム", createBitmapIconFromPng(u"icons/zoom.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
    # 前の画像
    self.m_prevFileTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"前の画像", createBitmapIconFromPng(u"icons/left.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
    # 次の画像
    self.m_nextFileTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"次の画像", createBitmapIconFromPng(u"icons/right.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None )
    #    
    self.m_wxApplicationToolbar.AddSeparator()
    # 変位分析    
    self.m_displacementTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"変位分析", createBitmapIconFromPng(u"icons/icon_001030_256.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    # 振動モード
    self.m_vibrationModeTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"振動モード", createBitmapIconFromPng(u"icons/icon_105950_256.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    # 空間差分    
    self.m_spatialDifferenceTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"空間差分", createBitmapIconFromPng(u"icons/icon_156790_256.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    # 減衰分析    
    self.m_dampedAnalysisTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"減衰分析", createBitmapIconFromPng(u"icons/icon_162440_256.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    #
    self.m_wxApplicationToolbar.AddSeparator()
    # 設定    
    self.m_settingTool = self.m_wxApplicationToolbar.AddTool( wx.ID_ANY, u"設定", createBitmapIconFromPng(u"icons/setting.png",iconW,iconH), wx.NullBitmap, wx.ITEM_NORMAL, wx.EmptyString, wx.EmptyString, None ) 
    #
    self.m_wxApplicationToolbar.Realize()

    # Connect Events
    self.Bind( wx.EVT_TOOL, self.m_openToolClick, id = self.m_openTool.GetId() )
    self.Bind( wx.EVT_TOOL, self.m_displacementToolClick, id = self.m_displacementTool.GetId() )
    self.Bind( wx.EVT_TOOL, self.m_vibrationModeToolClick, id = self.m_vibrationModeTool.GetId() )
    self.Bind( wx.EVT_TOOL, self.m_spatialDifferenceToolClick, id = self.m_spatialDifferenceTool.GetId() )
    self.Bind( wx.EVT_TOOL, self.m_dampedAnalysisToolClick, id = self.m_dampedAnalysisTool.GetId() )
    self.Bind( wx.EVT_TOOL, self.m_settingToolToolClick, id = self.m_settingTool.GetId() )
    self.Bind(wx.EVT_TOOL, self.m_homeToolClick, id=self.m_homeTool.GetId())
    self.Bind(wx.EVT_TOOL, self.m_captureToolClick, id=self.m_captureTool.GetId())
    self.Bind(wx.EVT_TOOL, self.m_zoomToolClick, id=self.m_zoomTool.GetId())
    self.Bind(wx.EVT_TOOL, self.m_prevFileToolClick, id=self.m_prevFileTool.GetId())
    self.Bind(wx.EVT_TOOL, self.m_nextFileToolClick, id=self.m_nextFileTool.GetId())

def createMovieTool(self):
        bSizer14 = wx.BoxSizer( wx.VERTICAL )
        self.figure = Figure()
        size = self.GetSize()
        self.SetSizeHints(980, size.height, size.width, size.height, -1, -1)
        w = size.width * 8/980
        h = size.height * 5.8/750
        self.figure.set_size_inches(w, h)
        self.figure.set_facecolor((0, 0, 0))
        self.canvas = FigureCanvasWxAgg(self, -1, self.figure)
        self.canvas.SetSize((980, 900))

        #MatPlot用イベント設定
        cid = self.figure.canvas.mpl_connect('button_press_event', self.onMouseClick)
        self.selectPoint = []
        self.selectPointc = []

        self.navigationToolbar = NavigationToolbar2Wx(self.canvas)
        self.navigationToolbar.Realize()
        bSizer14.Add(self.canvas, 0, wx.LEFT | wx.EXPAND)
        bSizer14.Add(self.navigationToolbar, 0, wx.LEFT | wx.EXPAND)
        self.navigationToolbar.update()
        bSizer14.Show(self.navigationToolbar, False)
        bSizer19 = wx.BoxSizer( wx.HORIZONTAL )


        self.m_slider1 = wx.Slider(self, wx.ID_ANY, 0, 0, 100, wx.DefaultPosition, wx.Size(size.width, 25),
                           wx.SL_LABELS | wx.FULL_REPAINT_ON_RESIZE)
        self.m_slider1.SetForegroundColour(wx.SystemSettings.GetColour(wx.SYS_COLOUR_BACKGROUND))
        bSizer19.Add( self.m_slider1, 0, wx.ALIGN_CENTER, 50 )
        bSizer14.Add( bSizer19, 1, wx.ALIGN_BOTTOM, 20 )
           
        bSizer21 = wx.BoxSizer( wx.VERTICAL )
        bSizer22 = wx.BoxSizer( wx.HORIZONTAL )
        self.m_bpButton14 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/player-4.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton14, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton15 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/player-6.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton15, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton16 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/player-2.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton16, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton17 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/player-1.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton17, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton18 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/player-5.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton18, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton19 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/player-3.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton19, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton20 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/home.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton20, 0, wx.ALIGN_CENTER, 5 )
        self.m_bpButton21 = wx.BitmapButton( self, wx.ID_ANY, createBitmapIconFromPng(u"icons/capture.png",iconW2,iconH2), wx.DefaultPosition, wx.DefaultSize, wx.BU_AUTODRAW )
        bSizer22.Add( self.m_bpButton21, 0, wx.ALIGN_CENTER, 5 )
        self.m_staticText4 = wx.StaticText( self, wx.ID_ANY, u"　　　　　　                         　　　　　", wx.DefaultPosition, wx.DefaultSize, 0 )
        self.m_staticText4.Wrap(-1)
        bSizer22.Add( self.m_staticText4, 0, wx.ALL, 5 )
        self.m_bpButton22 =wx.Button(self, wx.ID_ANY, u"BaseFrame設定", wx.DefaultPosition, wx.DefaultSize, 0)
        bSizer22.Add(self.m_bpButton22, 0, wx.ALIGN_CENTER)
        self.m_textCtrl5 = wx.TextCtrl( self, wx.ID_ANY, u"0",  wx.DefaultPosition, wx.DefaultSize, wx.TE_CENTRE)
        bSizer22.Add( self.m_textCtrl5, 0, wx.ALIGN_CENTER)

        self.m_staticText3 = wx.StaticText( self, wx.ID_ANY, u"表示倍率：", wx.DefaultPosition, wx.DefaultSize, wx.TE_CENTRE )
        self.m_staticText3.Wrap( -1 )
        self.m_staticText3.SetForegroundColour('#000000')
        bSizer22.Add( self.m_staticText3, 0, wx.ALIGN_CENTER)
        self.m_textCtrl4 = wx.TextCtrl( self, wx.ID_ANY, u"300",  wx.DefaultPosition, wx.DefaultSize, wx.TE_CENTRE)
        bSizer22.Add( self.m_textCtrl4, 0, wx.ALIGN_CENTER)

        bSizer21.Add( bSizer22, 1, wx.EXPAND, 5 )
        bSizer14.Add( bSizer21, 1, wx.EXPAND, 5 )
        self.SetSizer(bSizer14)
        self.Bind(wx.EVT_SLIDER, self.m_slider1ValueChange, id=self.m_slider1.GetId())
        self.Bind(wx.EVT_MENU, self.m_OnOpenMovie, id = self.m_fileMenuItem62.GetId())
        self.Bind(wx.EVT_MENU, self.m_OnOpenImg, id = self.m_fileMenuItem61.GetId())
        self.m_bpButton14.Bind( wx.EVT_BUTTON, self.movieRew )
        #self.m_bpButton15.Bind( wx.EVT_BUTTON, self.movieBack )
        self.m_bpButton16.Bind( wx.EVT_BUTTON, self.moviePause )
        self.m_bpButton17.Bind( wx.EVT_BUTTON, self.moviePlay )
        #self.m_bpButton18.Bind( wx.EVT_BUTTON, self.movieNext )
        self.m_bpButton19.Bind( wx.EVT_BUTTON, self.movieFfw )
        
# Implementing wxApplicationFrame
class setOP_Dialog(OP_Dialog.m_OP_Dialog):
    """
    観測点設定ダイアログ
    """
    def __init__(self, parent):
        OP_Dialog.m_OP_Dialog.__init__(self, parent)
        self.SetPosition((1400, 300))
        self.m_button1.Bind( wx.EVT_BUTTON,self.prev)
        self.m_button2.Bind( wx.EVT_BUTTON,self.next)
        self.m_sdbSizerCancel.Bind( wx.EVT_BUTTON, self.frame_close )
        self.m_sdbSizerOK.Bind( wx.EVT_BUTTON, self.frame_close )
        self.m_button4.Bind( wx.EVT_BUTTON, self.reset )
        self.m_toolButton.Bind( wx.EVT_BUTTON, self.load )
        self.parent = parent
        #self.m_textCtrl11.SetValue(self.parent.BlockNo + 1) 
        """
        global BaseSetting
        if BaseSetting:
            self.m_spinCtrl1.SetValue(str(self.params["block_w"]))
            self.m_spinCtrl2.SetValue(str(self.params["block_h"]))
            self.m_spinCtrl3.SetValue(str(self.params["shift"]))
            self.m_spinCtrl4.SetValue(str(self.params["scaled"]))
            self.m_spinCtrl51.SetValue(str(self.params["num_block"]))
            self.m_comboBox1.SetValue(self.params["type"])
            self.m_spinCtrl5.SetValue(str(self.params["stride_x"]))
            self.m_spinCtrl6.SetValue(str(self.params["stride_y"]))
            self.m_lineEdit.SetValue(self.params["fileno"])
            self.m_textCtrl11.SetValue(str(self.params["groupno"]))
        """
        self.params = {}
		
    def getParam(self, event):
        # パラメータの取得
        self.params["block_w"] = int(self.m_spinCtrl1.GetValue())
        self.params["block_h"] = int(self.m_spinCtrl2.GetValue())
        self.params["shift"] = int(self.m_spinCtrl3.GetValue())
        self.params["scaled"] = int(self.m_spinCtrl4.GetValue())
        self.params["num_block"] = int(self.m_spinCtrl51.GetValue())
        self.params["type"] = self.m_comboBox1.GetValue()
        self.params["stride_x"] = int(self.m_spinCtrl5.GetValue())
        self.params["stride_y"] = int(self.m_spinCtrl6.GetValue())
        self.params["fileno"] = self.m_lineEdit.GetValue()
        self.params["groupno"] = int(self.m_textCtrl11.GetValue())
        return self.params

    def load (self, event):
        # パラメータの取得
        self.m_toolButton.Disable()
        self.SetClientSize(0,0)
        #self.(-1,-1,style= wx.STAY_ON_TOP | wx.RESIZE_BORDER | wx.SYSTEM_MENU | wx.CAPTION | wx.CLIP_CHILDREN)
        dialog = wx.FileDialog(None, u'ファイルを選択してください', "", "", "*.pickle",)
        if dialog.ShowModal() == wx.ID_OK:
            file_path = dialog.GetPath()
            self.m_lineEdit.SetValue(file_path)
            file_path=dialog.GetPath()
            self.parent.load_data(file_path)
            self.parent.dispedit()
            self.parent.Item6 = False
            self.parent.Item7 = False
            self.parent.Item8 = False
            self.parent.m_analyzeMenuItem4.Enable(True)
            self.parent.m_analyzeMenuItem5.Enable(True)
            self.parent.m_analyzeMenuItem6.Enable(False)
            self.parent.m_analyzeMenuItem7.Enable(False)
            self.parent.m_analyzeMenuItem8.Enable(False)
        self.m_toolButton.Enable()
        self.SetClientSize( 413,447 )
    def prev(self, event):
        if self.parent.BlockNo == 0:
            dialog = wx.MessageDialog(None, '前ブロックはありません', '', style=wx.OK)
            dialog.ShowModal()
            dialog.Destroy()
            return
        self.m_textCtrl11.SetValue(str(self.parent.BlockNo)) 
        self.parent.BlockNo = self.parent.BlockNo - 1
        self.parent.dispedit()

    def next(self, event):
        if self.parent.BlockNo <= len(self.parent.pxpys) - 1:
            self.parent.BlockNo = self.parent.BlockNo + 1
            self.m_textCtrl11.SetValue(str(self.parent.BlockNo + 1)) 
        self.parent.dispedit()
        return
    def reset(self, event):
        self.m_lineEdit.SetValue('')
        self.parent.reset()
        self.parent.img_load()
        self.parent.Item6 = False
        self.parent.Item7 = False
        self.parent.Item8 = False
        self.parent.m_analyzeMenuItem4.Enable(False)
        self.parent.m_analyzeMenuItem5.Enable(False)
    def frame_close(self, event):
        global BaseSetting
        BaseSetting = False

        self.Close(True)
class setOP_Dialog2(setObsPoint_Dialog.m_setObsPoint_Dialog):
    """
    観測点表示ダイアログ
    """
    def __init__(self, parent=None):
        setObsPoint_Dialog.m_setObsPoint_Dialog.__init__(self, parent)
        self.m_sdbSizerCancel.Bind( wx.EVT_BUTTON, self.frame_close )
        self.m_sdbSizerOK.Bind( wx.EVT_BUTTON, self.getParam )
        self.params = {}

    def getParam(self, event):
        # パラメータの取得
        self.params["block_w"] = int(self.m_spinCtrl1.GetValue())
        self.params["block_h"] = int(self.m_spinCtrl2.GetValue())
        self.params["shift"] = int(self.m_spinCtrl3.GetValue())
        self.params["scaled"] = int(self.m_spinCtrl4.GetValue())
        self.params["num_block"] = int(self.m_spinCtrl51.GetValue())
        self.params["type"] = self.m_comboBox1.GetValue()
        self.params["stride_x"] = int(self.m_spinCtrl5.GetValue())
        self.params["stride_y"] = int(self.m_spinCtrl6.GetValue())
        self.params["fileno"] = self.m_lineEdit.GetValue()
        self.params["groupno"] = int(self.m_textCtrl11.GetValue())
        self.Close(True)
        return self.params


    def frame_close(self, event):

        self.Close(True)

realsize = 10000
selmax = 10


class setSt_Dialog2(SettingDialog.M_SettingDialog):
    """
    設定ダイアログ
    """
    def __init__(self, parent=None):
        #super().__init__(self, parent)
        SettingDialog.M_SettingDialog.__init__(self, parent)
        self.m_textCtrl2.SetValue(str(realsize))
        self.m_textCtrl21.SetValue(str(selmax))
        self.m_button1.Bind( wx.EVT_BUTTON, self.getParam )
        self.m_button2.Bind( wx.EVT_BUTTON, self.frame_close )
        print('innit')
        self.params = {}

        self.params2 = None
    def getParam(self, event):
        # パラメータの取得
        self.params["ActualValue"] = self.m_textCtrl2.GetValue()
        #self.params2 = self.m_textCtrl2.GetValue()
        global realsize
        realsize = self.m_textCtrl2.GetValue()
        global selmax
        selmax = self.m_textCtrl21.GetValue()
        self.Close(True)
        return 
    def getParam2(self):
        self.params2 = self.m_textCtrl2.GetValue()
        return int(self.params2)
    def frame_close(self, event):

        self.Close(True)

class runDialog(RunDialog.M_RunDialog):
    """
    設定ダイアログ
    """
    def __init__(self, parent=None):
        #super().__init__(self, parent)
        RunDialog.M_RunDialog.__init__(self, parent)
        self.timer = wx.Timer(self)
        self.Bind(wx.EVT_TIMER, self.OnTimer)
        self.timer.Start(int(1000/30))
        self.m_gauge1.SetValue(0)
        self.parent = parent
    def OnTimer(self):
        m_gauge1.SetValue(self.parent.runValue)
        return

class MainWindow( wxApplicationProject.wxApplicationFrame ):
    def __init__( self, parent ):
        wxApplicationProject.wxApplicationFrame.__init__( self, parent )
        #self.SetSizeHints(wx.Size(1200, 900), wx.Size(1200, 900))
        #self.Maximize()
        createMainevt(self)
        createToolbar(self)
        createMovieTool(self)
        createMainInit(self)
        self.zoomf = 0

    #メニューバー（名前をつけて保存）
    def m_fileMenuItem5Click(self, event ):
        self.saveDispdata()

    #メニューバー（終了）
    def m_fileMenuItem8Click( self, event ):
        self.Close(True)
    
    #メニューバー（分析開始）
    def m_analyzeMenuItem4MenuSelection(self, event ):
        self.createPyramid()
        self.Item6 = True
        self.Item7 = True
        self.Item8 = True
    #メニューバー（変位分析のみ開始）
    def m_analyzeMenuItem5MenuSelection(self, event ):
        ret = self.createPyramid()
        if ret == 0:
            self.Item6 = False
            self.Item7 = False
            self.Item8 = False
            self.m_analyzeMenuItem6.Enable(False)
            self.m_analyzeMenuItem7.Enable(False)
            self.m_analyzeMenuItem8.Enable(False)
    #メニューバー（振動モード分析のみ開始）
    def m_analyzeMenuItem6MenuSelection(self, event ):
        ret = self.createPyramid()
        if ret == 0:
            self.Item6 = True
            self.m_analyzeMenuItem6.Enable(False)
    #メニューバー（空間差分分析のみ開始）
    def m_analyzeMenuItem7MenuSelection(self, event ):
        ret = self.createPyramid()
        if ret == 0:
            self.Item7 = True
            self.m_analyzeMenuItem7.Enable(False)
    #メニューバー（減衰分析のみ実施）
    def m_analyzeMenuItem8MenuSelection(self, event ):
        ret = self.createPyramid()
        if ret == 0:
            self.Item8 = True
            self.m_analyzeMenuItem8.Enable(False)
    
    #メニューバー（観測点の指定）
    def m_analyzeMenuItem1MenuSelection( self, event ):
        #frame = OP_Dialog.m_OP_Dialog(self)
        global BaseSetting
        if not(BaseSetting):
            BaseSetting = True
            self.setopDialog = setOP_Dialog(self)
            self.setopDialog.Show(True)
        #event.Skip()

    #メニューバー（観測点の表示）
    def m_displayMenuItem9MenuSelection( self, event ):
        frame = setOP_Dialog2(self)
        frame.Show(True)
        #event.Skip()

    def m_openToolClick( self, event ):
        import configdata
        self.configdata = configdata
        dialog = wx.FileDialog(None, u'ファイルを選択してください', "", "", "*.pickle")
        if dialog.ShowModal() == wx.ID_OK:
            global PickleRead
            PickleRead = True

            self.selectPoint = []
            self.pickle_filepath = dialog.GetPath()
            self.dirpath = os.path.dirname(self.pickle_filepath)
            print(self.dirpath)
            with open(self.pickle_filepath, "rb") as f:
                data = pickle.load(f)
            # 画像ファイルの一覧取得（mp4,pgm, png, bmp形式に対応）
            self.configdata.image_filelist = search_ext.search(self.dirpath, ext_list=["mp4","pgm", "png", "bmp"])

            # 変位データのロード
            self.configdata.dis = data["displacement"].sel()
            self.configdata.pxpys = data["pxpys"].sel()
            self.configdata.bss = data["bss"].sel()
            if data["displacement_bg"] is not None:
                self.configdata.dis_bg = data["displacement_bg"].sel(layer=0)
                self.configdata.pxpys_bg = data["pxpys_bg"].sel(layer=0)
                self.configdata.bss_bg = data["bss_bg"].sel(layer=0)

            # 画像のロード
            self.frame_number = 0
            self.reset()
            self.img_load()
            self.m_slider1.SetMin(1)
            self.m_slider1.SetMax(len(configdata.image_filelist))

    # 変位分析表示
    def m_displacementToolClick( self, event ):
        frame = displacementWindow.DisplacementWindow(self)
        frame.Show(True)
        event.Skip()

    # 振動モード
    def m_vibrationModeToolClick( self, event ):
        frame = pcaWindow.PCAWindow(self)
        frame.Show(True)
        event.Skip()

    # Virtual event handlers, overide them in your derived class
    def m_spatialDifferenceToolClick( self, event):
        frame = spatialDifferenceWindow.SpatialDifferenceWindow(self)
        frame.Show(True)
        event.Skip()
    
    # Virtual event handlers, overide them in your derived class
    def m_dampedAnalysisToolClick( self, event):
        frame = dampedAnalysisWindow.DampedAnalysisWindow(self)
        frame.Show(True)
        event.Skip()

    # 変位たわみ表示
    def m_plotDispDef(self, event):
        frame = DisplacementDeflectionWindow.DisplacementDeflectionWindow(self)
        frame.Show(True)
        event.Skip()

    # 変位ベクトル表示
    def m_plotDispVector(self, event):
        frame = DisplacementVectorWindow.DisplacementVectorWindow(self)
        frame.Show(True)
        event.Skip()

    # 相対変位表示
    def m_Relativedisplacement(self, event):
        frame = RelativeDisplacementWindow.RelativeDisplacementWindow(self)
        frame.Show(True)
        event.Skip()


    # matplotlibツールバー設定画面
    #ホーム
    def m_homeToolClick(self, event):
        self.navigationToolbar.home()

        self.zoomf = 0
    #キャプチャー
    def m_captureToolClick(self, event):
        self.navigationToolbar.save_figure()
        event.Skip()

    #ズーム
    def m_zoomToolClick(self, event):
        self.navigationToolbar.zoom()
        self.zoomf = 1
        event.Skip()

    #前画面
    def m_prevFileToolClick(self, event):
        self.navigationToolbar.back()
        event.Skip()

    #次画面
    def m_nextFileToolClick(self, event):
        self.navigationToolbar.forward()
        event.Skip()

    #スライダー
    def m_slider1ValueChange(self, event):
        #self.frame_number  = self.m_slider1.GetValue() - 1
        #self.reset()
        #self.img_load()
        frame = self.m_slider1.GetValue() - 1
        if(self.isOpenPickleData == False):
            if(self.isOpenMovie == True):
                self.capMov.set( 1, frame) # CV_CAP_PROP_POS_FRAMES=1 指定フレームのセット
                self.movFlag, self.movFrame = self.capMov.read()
                self.im = cv2.cvtColor(
                    self.movFrame, cv2.COLOR_BGR2RGB)  # matplot形式
            else:
                cv2img = cv2.imread(self.configdata.image_filelist[frame])
                self.im = cv2.cvtColor(cv2img, cv2.COLOR_BGR2RGB)  # matplot形式
    # ツールバー設定画面
    def m_settingToolToolClick( self, event):
        frame = setSt_Dialog2(self)
        frame.Show(True)
        event.Skip()


    def onMouseClick(self, event):
        print('onMouseClick')

        """Intended to be called through "mpl_connect"."""
        # Rather than trying to interpolate, just display the clicked coords
        # This will only be called if it's within "tolerance", anyway.
        global BaseSetting
        x, y = event.xdata, event.ydata
        print('mouse Pick --',event.button, event.xdata, event.ydata)
        if x == None or y == None :
            return
        print(BaseSetting)
        if BaseSetting:  # 観測点の指定ダイアログが開いている場合
            self.setanalize(event)
        else:
            self.setconfig(event)
        self.dispedit()
        #    global selmax

    def m_bpButton22Click(self, event):
        """
        基準フレームの設定
        """
        self.frame_number = self.m_slider1.GetValue() - 1
        self.base_image = cv2.imread(self.file_list[self.frame_number], cv2.IMREAD_GRAYSCALE)
        self.m_textCtrl5.SetValue(str(self.frame_number + 1))
        event.Skip()


    def set_bss(self, bs):
        """
        bssのセッター

        :param bs:
        """
        if self.BlockNo > len(self.bss) - 1: 
            self.bss.append([])
        self.bss[self.BlockNo].append(bs)

    def set_pxpys(self, pxpy):
        """
        pxpysのセッター

        :param pxpy:
        """
        if self.BlockNo > len(self.pxpys) - 1:
            self.pxpys.append([])
        self.pxpys[self.BlockNo].append(pxpy)

    def reset(self):
        """
        選択点のリセット
        """
        self.pxpys = [[]]
        self.bss = [[]]
        self.pxpys_background = [[]]
        self.bss_background = [[]]
        self.selectPoint = []
        self.BlockNo = 0

    def setanalize(self,event):      
        """
        観測点指定
        """

        self.params = self.setopDialog.getParam(self)
        # 左クリック
        if event.button == 1:
            print('left click---')

            self.bs = np.array([self.params["block_w"], self.params["block_h"]])
            # 点の場合
            if self.params["type"] == "点":
                pxpy = np.array([event.xdata, event.ydata])
                pxpy = pxpy.astype(np.int)
                self.set_pxpys(pxpy)
                self.set_bss(self.bs)
            # 線の場合
            if self.params["type"] == "線":
                if not self.press_count:
                    self.first_pos = ([event.xdata, event.ydata])
                    self.press_count = True
                    return
                elif self.press_count:
                    distance_x = int((event.xdata - self.first_pos[0]) / (self.params["num_block"] - 1))
                    distance_y = int((event.ydata - self.first_pos[1]) / (self.params["num_block"] - 1))
                    pxpys = []
                    for i in range(self.params["num_block"]):
                        pxpy = np.array([self.first_pos[0] + i * distance_x, self.first_pos[1] + i * distance_y])
                        pxpy = pxpy.astype(np.int)
                        self.set_pxpys(pxpy)
                        self.set_bss(self.bs)
                        pxpys.append(pxpy)

                    self.press_count = False

                # 矩形の場合
            if self.params["type"] == "矩形":
                if not self.press_count:
                    self.first_pos = (np.array([event.xdata, event.ydata])).astype(np.int)
                    self.press_count = True
                elif self.press_count:
                    pxs = range(self.first_pos[0], int(event.xdata), self.params["stride_x"])
                    pys = range(self.first_pos[1], int(event.ydata), self.params["stride_y"])
                    pxpys = []
                    for pxpy in itertools.product(pxs, pys):
                        pxpy = pxpy.astype(np.int)
                        self.set_pxpys(pxpy)
                        self.set_bss(self.bs)
                        pxpys.append(pxpy)
                    self.press_count = False

            self.Item6 = False
            self.Item7 = False
            self.Item8 = False
            self.m_analyzeMenuItem4.Enable(True)
            self.m_analyzeMenuItem5.Enable(True)
            self.m_analyzeMenuItem6.Enable(False)
            self.m_analyzeMenuItem7.Enable(False)
            self.m_analyzeMenuItem8.Enable(False)

            # 右クリック
        elif event.button == 3:
            print('right click---')
            self.reset()

    def setconfig(self,event):      
        """
        分析点セット
        """
        for i in range(self.mpoint):
            if event.xdata <= self.stpoint_x[i] + (self.bsize / 2) and self.stpoint_x[i] - (self.bsize / 2) <= event.xdata:
                if event.ydata <= self.stpoint_y[i] + (self.bsize / 2) and self.stpoint_y[i] - (self.bsize / 2) <= event.ydata:
                    print('Index=%d' % i)
                    if i in self.selectPoint:  # すでに登録されていたら消す
                        c = self.selectPoint.index(i)
                        self.colordl.append(self.selectPointc[c])
                        self.selectPointc.pop(c)
                        self.selectPoint.remove(i)
                    else:
                        self.selectPoint.append(i)
                        if len(self.colordl) > 0:
                            self.selectPointc.append(self.colordl.pop(0))
                        else:
                            self.selectPointc.append(colorlist[(len(self.selectPoint) -1) % 7])

    def dispedit(self):      
        """
        観測点・分析点表示
        """
        xlim = self.axes.get_xlim()
        ylim = self.axes.get_ylim()
        self.axes.cla()
        self.axes = self.figure.add_subplot(111, facecolor='black')
        #self.axes.set_xlim(xlim)
        #self.axes.set_ylim(ylim)
        #観測点表示
        if len(self.pxpys) > self.BlockNo:
            if len(self.pxpys[self.BlockNo]) > 0:
                rects = self.pxpys[self.BlockNo] - (np.array(self.bss[self.BlockNo]) / 2)  
                rects = rects.astype(np.int)
                bss = np.array(self.bss[self.BlockNo]).reshape(len(self.bss[self.BlockNo]), -1)
                print(bss.shape)
                for i in range(len(self.pxpys[self.BlockNo])):
                    self.axes.add_patch(mpatches.Circle(xy=tuple(self.pxpys[self.BlockNo][i]), radius=4, facecolor='blue', edgecolor='blue')) 
                    self.axes.add_patch(mpatches.Rectangle(xy=tuple(rects[i]), width=bss[i][0], height=bss[i][1], angle=0,
                                                                  linewidth='2.0', facecolor='none', edgecolor='lightblue'))
        #分析点表示
        global PickleRead
        if PickleRead == True:
            self.mpoint = self.configdata.dis.shape[1]  # 測定位置の仮設定
            self.stpoint_x = self.configdata.pxpys.sel(layer=0, features="x").values
            self.stpoint_y = self.configdata.pxpys.sel(layer=0, features="y").values
            self.bsize = self.configdata.bss.sel(point=0,layer=0, features="y").values
            rects = [self.stpoint_x, self.stpoint_y] - (np.array(self.bsize) / 2)
            rects = rects.astype(np.int)
            for i in range(self.mpoint):
                self.axes.add_patch(mpatches.Rectangle(xy=tuple([rects[0][i],rects[1][i]]), angle=0, 
                                            width=self.bsize, height=self.bsize, edgecolor='red', alpha=0.4))
            for i in range(self.mpoint):
                if i in self.selectPoint:
                    self.axes.add_patch(mpatches.Rectangle(xy=tuple([rects[0][i],rects[1][i]]), angle=0,
                                           width=self.bsize, height=self.bsize, facecolor=self.selectPointc[self.selectPoint.index(i)], edgecolor='red',alpha=0.8,))
                else:
                    self.axes.add_patch(mpatches.Rectangle(xy=tuple([rects[0][i],rects[1][i]]), angle=0,
                                        width=self.bsize, height=self.bsize, edgecolor='red',alpha=0.3,))
        self.axes.minorticks_on()
        self.axes.tick_params(axis='both', which='major', direction='inout', colors="black", labelsize=8, bottom='on',
                                  left='on')
        self.axes.grid(True)
        self.axes.tick_params(axis='both', which='minor', direction='inout', length=5, colors="black")
        self.axes.imshow(self.im)
        
        self.figure.canvas.draw()
    def m_OnOpenImg(self, event):
        dialog = wx.DirDialog(None, u'画像フォルダを選択してください')
        if dialog.ShowModal() == wx.ID_OK:
            global PickleRead
            PickleRead = False

            self.dirpath = dialog.GetPath()
            #self.dirpath = os.path.dirname(dialog.GetPath())
            import configdata
            self.configdata = configdata # configdataの初期化
            self.mpoint = [] # 選択点の初期化
            # 画像ファイルの一覧取得（pgm, png, bmp形式に対応）
            self.configdata.image_filelist = search_ext.search(self.dirpath, ext_list=["pgm", "png", "bmp"])
            fileMaxNum = len(configdata.image_filelist)
            if(fileMaxNum>0):
                self.isOpenMovie = False
                self.isOpenPickleData = False
                # 画像読み込み／変換
                cv2img = cv2.imread(self.configdata.image_filelist[0])
                self.im = cv2.cvtColor(cv2img, cv2.COLOR_BGR2RGB)  # matplot形式
                # axesを一旦消去
                if self.axes :
                    self.axes.cla()
                # axesを再設定
                self.axes = self.figure.add_subplot(111, facecolor='black')
                self.axes.minorticks_on()
                self.axes.tick_params(axis='both', which='major', direction='inout', colors="black", labelsize=8, bottom='on',
                              left='on')
                self.axes.grid(True)
                self.axes.tick_params(axis='both', which='minor', direction='inout', length=5, colors="black")                
                # 画像表示
                self.axes.imshow(self.im)
                self.figure.canvas.draw()
                # スライダー設定
                self.m_slider1.SetMin(1)
                self.m_slider1.SetMax(len(configdata.image_filelist))
                # Timerイベントの設定
                self.timer = wx.Timer(self)
                self.Bind(wx.EVT_TIMER, self.OnTimer)
                self.timer.Start(int(1000/30))
                self.moviePlay = False
                self.movieRate = 1                             

    def m_OnOpenMovie(self, evet):
        dialog = wx.FileDialog(None, u'ファイルを選択してください', "", "", "*.mp4")
        if dialog.ShowModal() == wx.ID_OK:
            global PickleRead
            PickleRead = False

            fileName = os.path.dirname(dialog.GetPath())+'\\'+dialog.Filename
            self.capMov = cv2.VideoCapture(fileName)            
            if(self.capMov.isOpened()):
                self.isOpenPickleData = False
                self.isOpenMovie = True
                import configdata
                self.configdata = configdata # configdataの初期化
                self.mpoint = [] # 選択点の初期化
                max_frame=self.capMov.get(7) # CV_CAP_PROP_FRAME_COUNT=7 フレーム数
                fps=self.capMov.get(5) # CV_CAP_PROP_FPS=5 フレームレート
                print('FileName: ', fileName)
                print('FrameNum: ', max_frame)
                print('FPS: ', fps)
                self.m_slider1.SetMin(1)
                self.m_slider1.SetMax(max_frame)
                # axesを一旦消去
                if self.axes :
                    self.axes.cla()
                # axesを再設定
                self.axes = self.figure.add_subplot(111, facecolor='black')
                
                self.movFlag, self.movFrame = self.capMov.read()
                self.im = cv2.cvtColor(
                    self.movFrame, cv2.COLOR_BGR2RGB)  # matplot形式
                self.axes.minorticks_on()
                self.axes.tick_params(axis='both', which='major', direction='inout', colors="black", labelsize=8, bottom='on',
                              left='on')
                self.axes.grid(True)
                self.axes.tick_params(axis='both', which='minor', direction='inout', length=5, colors="black")
                self.axes.imshow(self.im)
                self.figure.canvas.draw()
                # Timerイベントの設定
                self.timer = wx.Timer(self)
                self.Bind(wx.EVT_TIMER, self.OnTimer)
                self.timer.Start(int(1000/fps))
                self.moviePlay = False
                self.movieRate = 1             
    def movieRew(self, event):
        if(self.moviePlay == True):
            if(self.movieRate > 0):
                self.movieRate = -2
            else:
                self.movieRate -= 1
    def moviePause(self, event):
        if(self.moviePlay == True):
            self.moviePlay = False
            self.movieRate = 1

    def moviePlay(self, event):
        if(self.moviePlay == False):
            self.moviePlay = True
            self.movieRate = 1
        else:
            self.movieRate = 1
    
    def movieFfw(self, evet):
        if(self.moviePlay == True):        
            if(self.movieRate < 0):
                self.movieRate = 2
            else:
                self.movieRate += 1

    def OnTimer(self, event):
        if(self.moviePlay == True):
            current = self.m_slider1.GetValue()
            now = current + self.movieRate
            if( now < 1):
                now = 1
                moviePlaye = False
            if( now > self.m_slider1.GetMax()):
                now = self.m_slider1.GetMax()
                moviePlay = False
            self.m_slider1.SetValue(now)
            frame = self.m_slider1.GetValue() - 1
            if(self.isOpenMovie == True):
                self.capMov.set( 1, frame) # CV_CAP_PROP_POS_FRAMES=1 指定フレームのセット
                self.movFlag, self.movFrame = self.capMov.read()
                self.im = cv2.cvtColor(
                        self.movFrame, cv2.COLOR_BGR2RGB)  # matplot形式
            else:
                cv2img = cv2.imread(self.configdata.image_filelist[frame])
                self.im = cv2.cvtColor(cv2img, cv2.COLOR_BGR2RGB)  # matplot形式
            self.axes.imshow(self.im)
            self.figure.canvas.draw()
                   
    def img_load(self):
        with open(self.pickle_filepath, "rb") as f:
            data = pickle.load(f)
        self.configdata.dis = data["displacement"].sel()
        self.configdata.pxpys = data["pxpys"].sel()
        self.configdata.bss = data["bss"].sel()
        cv2img = cv2.imread(self.configdata.image_filelist[self.frame_number])
        self.im = cv2.cvtColor(cv2img, cv2.COLOR_BGR2RGB)  # matplot形式
        self.figure.subplots_adjust(left=0.005, right=0.995, bottom=0.1, top=0.9)
        self.axes = self.figure.add_subplot(111, facecolor='black')
        self.dispedit()

    def test(self, image_paths):
        print(image_paths[1])
        np.save(r"c:\\temp\\" + os.path.basename(image_paths[1])[:-4],np.zeros(10))
        #d = Displacement(image_list=self.configdata.image_filelist,
        #                 base_num=self.frame_number,
        #                 pxpys=self.pxpys_run,
        #                 bss=self.bss_run,
        #                 scale=self.params["scaled"],
        #                 shift=self.params["shift"]
        #                 )
        #d.one_pair_calculation(image_paths)

    def createPyramid(self):
        if len(self.pxpys) == 0:
            dialog = wx.MessageDialog(None, '観測点の指定がありません', '分析開始エラー', style=wx.OK)
            dialog.ShowModal()
            dialog.Destroy()
            return 1 

        runframe = runDialog(self)
        runframe.Show(True)
        self.results = []
        total_frame = len(self.configdata.image_filelist)

        tmp_pxpys = []
        tmp_bss = []

        # Pyramid検出フラグ
        self.is_pyramid = False
        # レイヤー作成
        self.pyramid_pxpys, self.pyramid_bss = pyramid_stride(pxpys=self.pxpys[0],
                                                              bss=self.bss[0],
                                                              layers_bs=self.layers_bs,
                                                              layers_stride=self.layers_stride,
                                                              is_pyramid=self.is_pyramid)
        x_pxpys = []
        x_bss = []
        self.pyramid_pxpys_bg, self.pyramid_bss_bg = pyramid_stride(pxpys=self.pxpys_background,
                                                                    bss=self.bss_background,
                                                                    layers_bs=self.layers_bs,
                                                                    layers_stride=self.layers_stride,
                                                                    is_pyramid=self.is_pyramid)

        # レイヤーの展開
        self.expand_pxpys, self.expand_bss = expand_layers(self.pyramid_pxpys, self.pyramid_bss)
        self.expand_pxpys_bg, self.expand_bss_bg = expand_layers(self.pyramid_pxpys_bg, self.pyramid_bss_bg)

        # 計測点（バックグラウンド以外）の個数（展開時)
        self.len_pyramid = len(self.expand_pxpys)

        # 結合
        tmp_pxpys.extend(self.expand_pxpys)
        tmp_pxpys.extend(self.expand_pxpys_bg)
        tmp_bss.extend(self.expand_bss)
        tmp_bss.extend(self.expand_bss_bg)
        self.pxpys_run = tmp_pxpys
        self.bss_run = tmp_bss
        self.runValue = 20
        print('pxpys_run=',self.pxpys_run)
        #runframe.m_gauge1.SetValue(20)

        # プログレスバーの初期化
        #self.ui.progressBar.setFormat("%p%")
        # 変位計測の実行
        self.is_sampling = False
        d = Displacement(image_list=self.configdata.image_filelist,
                         base_num=self.frame_number,
                         pxpys=self.pxpys_run,
                         bss=self.bss_run,
                         scale=self.params["scaled"],
                         shift=self.params["shift"]
                         )
        it = d.run()
        #runframe.m_gauge1.SetValue(30)
        self.runValue = 30

        # 結果の取り出し
        print(it)
        for i, result in enumerate(it):
            self.results.append(result)
            #runframe.m_gauge1.SetValue((i + 1) / total_frame + 30 * 100)
            self.runValue = ((i + 1) / total_frame + 30 * 100)
        #p = Pool(processes=cpu_count())
        #iterable = [p.apply_async(func,([self.configdata.image_filelist[self.frame_number], self.configdata.image_filelist[i]]
        #                for i in range(len(self.configdata.image_filelist))]
        #func = d.one_pair_calculation
        #func = self.test
        #for i in range(len(self.configdata.image_filelist)): 
        #    #p.apply_async(func,args=([self.configdata.image_filelist[self.frame_number], self.configdata.image_filelist[i]],))
        #    print('self.configdata.image_filelist[i]=',self.configdata.image_filelist[i])
        #    p.apply_async(func,([self.configdata.image_filelist[self.frame_number], self.configdata.image_filelist[i]],))
        #    #p.map(func,[self.configdata.image_filelist[self.frame_number], self.configdata.image_filelist[i]])
        #p.close()
        #del p
        #i = 0
        #while i < len(self.configdata.image_filelist) -1 :
        #    if os.path.exists(r"c:\\temp\\" + os.path.basename(self.configdata.image_filelist[i+1])[:-4] + u".npy"):
        #        cp = np.load(r"c:\\temp\\" + os.path.basename(self.configdata.image_filelist[i+1])[:-4] + u".npy")
        #        self.results.append(cp)
        #        runframe.m_gauge1.SetValue((i + 1) / total_frame + 30 * 100)
        #        i = i + 1
        self.createDispdata()
        """
        if len(self.results) == len(it):
            dialog = wx.MessageDialog(None, '正常終了しました！！', '処理終了', style=wx.OK)
            dialog.ShowModal()
            dialog.Destroy()
        else:
        """
        #dialog = wx.MessageDialog(None, '画像' + str(len(it) - len(self.results)) + '件 異常終了しました！！', '処理終了', style=wx.OK)
        #dialog.ShowModal()
        #dialog.Destroy()

        runframe.Close(True)

        return 0

    def createDispdata(self):
        results_all = np.array(self.results)
        print('results_all=',results_all.shape)
        if not self.is_sampling:
            # サンプリング時とshapeを同じにする
            results_all = results_all[:, np.newaxis, :, :]

        # 統計量の推定
        results_all = robust_statistics_with_mad(results_all)

        # DataArrayのdims & coords
        dims_displacement = ["time", "point", "layer", "features", "stats"]
        coords_displacement = {"features": ["dis_x", "dis_y",  # 変位
                                            "max_corr"],  # 相関係数
                               "stats": ["mu", "sigma"]}  # 統計量
        # 測定点およびブロックサイズのdims & coords
        dims_pxpy_bs = ["point", "layer", "features"]
        coords_pxpy_bs = {"features": ["x", "y"]}
        # Back groundと計測点の分割
        print('self.len_pyramid',self.len_pyramid) 
        results = results_all[:, :self.len_pyramid, :, :]
        results_background = np.delete(results_all, list(range(self.len_pyramid)), axis=1)
        print('results_background',results_background)
        # レイヤー毎に結果を再構成
        layered_results = reconstruct_layers(results, self.pyramid_pxpys,
                                             dims=dims_displacement, coords=coords_displacement,
                                             displacement=True)
        layered_results_bg = reconstruct_layers(results_background, self.pyramid_pxpys_bg,
                                                dims=dims_displacement, coords=coords_displacement,
                                                displacement=True)
        pxpys = reconstruct_layers(self.expand_pxpys, self.pyramid_pxpys,
                                   dims=dims_pxpy_bs, coords=coords_pxpy_bs, displacement=False)
        bss = reconstruct_layers(self.expand_bss, self.pyramid_bss,
                                 dims=dims_pxpy_bs, coords=coords_pxpy_bs, displacement=False)
        pxpys_bg = reconstruct_layers(self.expand_pxpys_bg, self.pyramid_pxpys_bg,
                                      dims=dims_pxpy_bs, coords=coords_pxpy_bs, displacement=False)
        bss_bg = reconstruct_layers(self.expand_bss_bg, self.pyramid_bss_bg,
                                    dims=dims_pxpy_bs, coords=coords_pxpy_bs, displacement=False)

        # 保存するDataSet
        self.ds = {"displacement": layered_results,
              "pxpys": pxpys,
              "bss": bss,
              "displacement_bg": layered_results_bg,
              "pxpys_bg": pxpys_bg,
              "bss_bg": bss_bg,
              "shift": self.params["shift"],
              "scale": self.params["scaled"],
              "is_pyramid": self.is_pyramid,
              }
        print()
        import configdata
        self.configdata = configdata
        self.configdata.dis = self.ds["displacement"].sel()
        self.configdata.pxpys = self.ds["pxpys"].sel()
        self.configdata.bss = self.ds["bss"].sel()
        self.reset()
        self.dispedit()
        self.selectPoint = []

    def saveDispdata(self):
        """
        結果の保存
        保存場所：名前をつけて保存
        保存形式：辞書型
        　　　　 変位結果、計測点、ブロックサイズはxr.DataArray形式
        """
        # pickle形式で保存
        save_pickle(self.ds)

    def load_data(self,file_path):
        restored_results = load(file_path)
        #self.m_pxpys = []
        #self.m_bss = []
        #self.m_pxpys_background = []
        #self.m_bss_background = []
        self.pxpys[0].extend(restored_results["pxpys"].sel(layer=0).values.astype(np.int64))
        self.bss[0].extend(restored_results["bss"].sel(layer=0).values.astype(np.int64))

        #if restored_results["displacement_bg"].any():
        #    self.m_pxpys_background.extend(restored_results["pxpys_bg"].sel(layer=0).values.astype(np.int64))
        #    self.m_bss_background.extend(restored_results["bss_bg"].sel(layer=0).values.astype(np.int64))
    

def pyramid_stride(pxpys, bss, layers_bs, layers_stride, is_pyramid):
    """
    pyramid分割
    ブロックサイズとストライドを指定して分割
    辞書形式でレイヤー毎に保存(キーは"layer_n", nは連番, 1からスタート)
    pyramid_layers_pxpys = {"layer_1": pxpys, "layer_2": pxpys, ..., "layer_n": pxpys}

    :param pxpys: 計測点の座標

    :param bss: ブロックサイズ
    :param layers_bs: レイヤー毎のブロックサイズ
    :param layers_stride: レイヤー毎のストライド幅
    :param is_pyramid: ピラミッドフラグ
    :rtype: dict, dict
    """
    pyramid_layers_pxpys = {"layer_1": np.array(pxpys)}
    pyramid_layers_bss = {"layer_1": np.array(bss)}
    # pyramid検出のみ以下を実行
    if is_pyramid and pxpys:
        layers_bs = np.array(layers_bs)
        layers_stride = np.array(layers_stride)
        for i, (bs, stride) in enumerate(zip(layers_bs, layers_stride)):
            add_pxpys = []
            add_bss = []
            num = ((bss - bs) / stride + 1).astype(int)
            for p, b, n in zip(pxpys, bss, num):
                px = np.linspace(start=0, stop=b[0] - bs[0], num=n[0], dtype=np.int)
                py = np.linspace(start=0, stop=b[1] - bs[0], num=n[1], dtype=np.int)
                pxpy = np.array(list(product(px, py)))
                add_pxpys.extend(p + pxpy)
                add_bss.extend(np.tile(bs, [len(pxpy), 1]))
            pyramid_layers_pxpys["layer_{}".format(i + 2)] = np.array(add_pxpys)
            pyramid_layers_bss["layer_{}".format(i + 2)] = np.array(add_bss)
    return pyramid_layers_pxpys, pyramid_layers_bss

def expand_layers(pyramid_pxpys, pyramid_bss):
    """
    layer毎に保存されていたpxpys, bssを展開して一つのリストに変換
    上から順に上位のlayerが並ぶようになっている

    :param pyramid_pxpys:
    :param pyramid_bss:
    :return:
    """
    expand_pxpys = []
    expand_bss = []
    for (k1, v1), (k2, v2) in zip(sorted(pyramid_pxpys.items(), key=lambda x: x[0]),
                                  sorted(pyramid_bss.items(), key=lambda x: x[0])):
        expand_pxpys.extend(v1)
        expand_bss.extend(v2)
    return np.array(expand_pxpys), np.array(expand_bss)
def reconstruct_layers(results, pyramid_pxpys, dims, coords, displacement):
    """
    結果をレイヤーごとに保存

    :param results: 変位計測結果
    :param pyramid_pxpys: レイヤー
    :param dims: 軸の名前
    :param coords: 結果の内訳
    :param displacement: 変位結果 or pxpys, bss
    :return: レイヤー毎の結果
    :rtype: xr.DataArray
    """
    layered_results = {}
    if results.any():
        # coords用(レイヤー毎の計測点を計測)
        points_per_layer = []
        measurement_points = 0
        frame = 0
        features = 0
        stats = 0
        for i, (k, v) in enumerate(sorted(pyramid_pxpys.items(), key=lambda x: x[0])):
            num = len(v)
            if i == 0:
                # 計測点の数
                measurement_points = num
                # 結果格納用の空配列の作成
                if displacement:
                    frame = results.shape[0]
                    features = results.shape[2]
                    stats = results.shape[3]
                    layered_results = np.empty(shape=(frame, measurement_points, 0, features, stats))
                else:
                    layered_results = np.empty(shape=(measurement_points, 0, results.shape[-1]))
            # 変位結果の時
            if displacement:
                # (frame, point, layer, features, stats)の形に変形
                print('frame, measurement_points, -1, features, stats',frame, measurement_points, -1, features, stats)
                print('num',num)
                print('results',results)
                layer = results[:, :num, :].reshape(frame, measurement_points, -1, features, stats)
                # concat
                layered_results = np.concatenate((layered_results, layer), axis=2)
                results = np.delete(results, list(range(num)), axis=1)
                # 計測点の数
                points_per_layer.extend([i] * layer.shape[2])
            # 計測点 or ブロックサイズの時
            else:
                # (point, layer, features)の形に変形
                layer = results[:num, :].reshape(measurement_points, -1, results.shape[-1])
                # concat
                layered_results = np.concatenate((layered_results, layer), axis=1)
                results = np.delete(results, list(range(num)), axis=0)
                # 計測点の数
                points_per_layer.extend([i] * layer.shape[1])
        # layerのcoordsの設定
        coords["layer"] = points_per_layer
        # to xarray
        layered_results = xr.DataArray(layered_results, dims=dims, coords=coords)
    else:
        layered_results = None
    return layered_results


